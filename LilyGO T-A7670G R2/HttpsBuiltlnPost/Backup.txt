Here is the entire code file for you to analyse, could you pinpoint where could be the point of failure and causing the crash? The code is running fine with just topple detection and gps task, but after I added in the bms serial and the led functions, it starts crashing everytime it is doing a http post
/**
 * @file      HttpsBuiltlnPost.ino
 * @author    Lewis He (lewishe@outlook.com)
 * @license   MIT
 * @copyright Copyright (c) 2023  Shenzhen Xin Yuan Electronic Technology Co., Ltd
 * @date      2023-11-29
 * @note
 * * Example is suitable for A7670X/A7608X/SIM7670G/SIM7000G/SIM7600 series
 * * Connect https://httpbin.org test post request
 * * Example uses a forked TinyGSM <https://github.com/lewisxhe/TinyGSM>, which will not compile successfully using the mainline TinyGSM.
 */
#define TINY_GSM_RX_BUFFER 1024 // Set RX buffer to 1Kb

// See all AT commands, if wanted
// #define DUMP_AT_COMMANDS

#include "utilities.h"
#include <TinyGsmClient.h>

//added
#include <Arduino.h>
#include <Wire.h>
#include <MPU9250_asukiaaa.h>
#include <TinyGPS++.h>
#include <HardwareSerial.h>
#include <SoftwareSerial.h>
#include <esp_now.h>
#include <WiFi.h>
#include <math.h>
#include <daly-bms-uart.h>
TinyGPSPlus gps;
MPU9250_asukiaaa mpu;
#define BOARD_GPS_TX_PIN                    0//36//21
#define BOARD_GPS_RX_PIN                    39//22
//#define SerialGPS Serial2
SoftwareSerial SerialGPS(BOARD_GPS_RX_PIN, BOARD_GPS_TX_PIN); // ESP32 RX, TX
#define buzzerPin 15
#define SDA_PIN 21
#define SCL_PIN 22
#define BMS_TX 23
#define BMS_RX 19
#define BMS_SERIAL Serial2
//SoftwareSerial BMS_SERIAL(BMS_TX, BMS_RX); // ESP32 RX, TX
Daly_BMS_UART bms(BMS_SERIAL);
// BMS
// 0 = ACTUAL (read BMS), 1 = MANUAL (fixed values), 2 = AUTO (sweep)
#define TEST_MODE 2
#if (TEST_MODE < 0) || (TEST_MODE > 2)
#error "TEST_MODE must be 0 (ACTUAL), 1 (MANUAL), or 2 (AUTO)"
#endif
// NOTE - Auto test globals
int test_case = 1; // 1 is discharge, 2 is charge
uint32_t AUTO_TEST_MS = 1000;
uint32_t lastAutoTestms = 0;

// GPS
float latitude = 1.2962018;     //Storing the Latitude
float longitude = 103.776899437848;    //Storing the Longitude
//Ice cave/E1A : 1.299610, 103.77770683
float velocity;     //Variable  to store the velocity
float speed_mps;
String bearing;     //Variable to store orientation or direction of GPS

// Fall/Ditch Detection
// indicating a state of freefall. (1g = 9.8 m/s^2)
const float FALL_ACCEL_THRESHOLD = 9.0;
const float g = 9.80665; //gravitational acceleration
// --- State Variables ---
bool potentialFall = false;
unsigned long lastUpdateTime = 0;
const unsigned long SENSOR_READ_INTERVAL = 1000; // Read sensors every 100ms
float Gyro = 0;
float Accel = 0;
const int numReadings = 10;    // Number of readings to average
float readingsAccel[numReadings];     // Array to store readings
float totalAccel = 0;                 // Sum of readings
float averageAccel = 0;   
float readingsGyro[numReadings];     // Array to store readings
float totalGyro= 0;                 // Sum of readings
float averageGyro = 0;  
int count = 0; 
bool zeroing = false;
int ind = 10;
float roll = 0;
float pitch = 0;
unsigned long fallTime = 0;
const unsigned long stillTime = 5000; // seconds of stillness
const int looptime = 1000;//every loop is 500ms for topple detection
unsigned long printTime = 0;
unsigned long postTime = 0;
const unsigned long postInterval = 15000; // 15 seconds for each HTTP post
String pmaState = "Safe";

// // ------------------------------------- ESP-NOW Setup -------------------------------------
// //! MAC Address of responder - edit as required
// uint8_t responderAddress[] = {0x38, 0x18, 0x2B, 0xF0, 0x8C, 0x14}; // 38:18:2B:F0:8C:14
// // how often to ESP-NOW send
// constexpr uint32_t SEND_PERIOD_MS = 500;
// uint32_t lastSendMs = 0;
// // Define a data structure
// typedef struct struct_message
// {
//     bool bms_status;
//     float soc;
//     float I;
//     float resmAh;
// } struct_message;
// // Create a structure object
// struct_message BMSData;
// // Peer info
// esp_now_peer_info_t peerInfo;
// // Helper function to format MAC Addresses
// void formatMacAddress(const uint8_t *macAddr, char *buffer, int maxLength)
// {
//     snprintf(buffer, maxLength, "%02x:%02x:%02x:%02x:%02x:%02x", macAddr[0], macAddr[1], macAddr[2], macAddr[3], macAddr[4], macAddr[5]);
// }
// // Callback function that you want to call when data is sent
// // The arguments of the callback function are fixed to be this two.
// void sendingCallback(const uint8_t *mac_addr, esp_now_send_status_t status)
// {
//     char macStr[18];
//     formatMacAddress(mac_addr, macStr, 18);
//     Serial.print("Last Packet Sent to: ");
//     Serial.println(macStr);
//     Serial.print("Last Packet Send Status: ");
//     // Serial.println(status);
//     Serial.println(status == ESP_NOW_SEND_SUCCESS ? "Send Success" : "Send Fail");
// }
// ------------------------------------- BMS Input Setup -------------------------------------
float input_soc = -1.0f; // raw SoC from BMS (float) //! all the previous shit do at responder side
float input_I = -1.0f;   // +A charge, -A discharge
float input_resmAh = -1.0f;
bool bms_ok = false;
// ------------------------------------- RGB LED Setup -------------------------------------
#define LED_R_PIN 19
#define LED_G_PIN 18
#define LED_B_PIN 32
#define LEDC_FREQ_HZ 5000
#define LEDC_RES_BITS 8
#define LEDC_MAX ((1 << LEDC_RES_BITS) - 1)
#define LEDC_CH_R 0
#define LEDC_CH_G 1
#define LEDC_CH_B 2
inline void ledcWrite255(uint8_t ch, uint8_t v)
{
    ledcWrite(ch, v);
}
inline void ledSetRGB255(uint8_t r, uint8_t g, uint8_t b)
{
    ledcWrite255(LEDC_CH_R, r);
    ledcWrite255(LEDC_CH_G, g);
    ledcWrite255(LEDC_CH_B, b);
}
inline void ledAllOff()
{
    ledSetRGB255(0, 0, 0);
}
typedef struct RgbColor
{
    uint8_t r, g, b;
} RgbColor;
RgbColor colourForSOC_LED(int soc)
{
    if (soc <= 40)
        return {255, 0, 0}; // red
    if (soc <= 80)
        return {255, 220, 0}; // yellow
    return {0, 255, 0};       // green
}
enum class Status : uint8_t
{
    None = 0,
    Charging,
    Full,
    Low
};
enum LedMode : uint8_t
{
    LED_OFF_MODE,
    LED_FLASH3_RED_MODE,
    LED_FLASH_CHG_MODE,
    LED_SOLID_FULL_MODE
};
static const uint16_t LOW_TRIPLE_MS[] = {120, 120, 120, 120, 120, 120, 1000};
constexpr uint8_t LOW_TRIPLE_LEN = sizeof(LOW_TRIPLE_MS) / sizeof(LOW_TRIPLE_MS[0]);
constexpr uint16_t CHG_ON_MS = 2000, CHG_OFF_MS = 2000;
Status g_status = Status::None;
Status g_prevStatus = Status::None;
LedMode g_ledMode = LED_OFF_MODE;
LedMode g_prevLedMode = LED_OFF_MODE;
uint8_t g_seqIndex = 0; // triple-flash state
uint32_t g_seqStampMs = 0;
bool g_chgOnPhase = false; // charge flash state
uint32_t g_chgStampMs = 0;
//template <typename T>
static inline int clampi(int v, int lo, int hi) 
{
    return v < lo ? lo : (v > hi ? hi : v);
}
void statusMessage(int soc, int chg)
{
    if (chg && soc < 100)
        g_status = Status::Charging;
    else if (chg && soc == 100)
        g_status = Status::Full;
    else if (soc <= 20)
        g_status = Status::Low;
    else
        g_status = Status::None;
}
LedMode computeLedMode(int soc, int chg, Status s)
{
    if (s == Status::Full && chg == 1 && soc == 100)
        return LED_SOLID_FULL_MODE;
    if (s == Status::Low && chg == 0 && soc <= 20)
        return LED_FLASH3_RED_MODE;
    if (chg == 1 && soc < 100)
        return LED_FLASH_CHG_MODE;
    return LED_OFF_MODE;
}
void updateLED(int soc, int chg)
{
    LedMode want = computeLedMode(soc, chg, g_status);

    if (want != g_prevLedMode)
    {
        g_seqIndex = 0;
        g_seqStampMs = millis();
        g_chgOnPhase = false;
        g_chgStampMs = millis();
        g_prevLedMode = want;
    }
    g_ledMode = want;

    uint32_t now = millis();
    switch (g_ledMode)
    {
    case LED_OFF_MODE:
        ledAllOff();
        break;

    case LED_SOLID_FULL_MODE:
    {
        RgbColor c = colourForSOC_LED(100);
        ledSetRGB255(c.r, c.g, c.b);
        break;
    }

    case LED_FLASH3_RED_MODE:
    {
        bool on = (g_seqIndex < 6) && ((g_seqIndex % 2) == 0);
        ledSetRGB255(on ? 255 : 0, 0, 0);
        if (now - g_seqStampMs >= LOW_TRIPLE_MS[g_seqIndex])
        {
            g_seqIndex = (g_seqIndex + 1) % LOW_TRIPLE_LEN;
            g_seqStampMs = now;
        }
        break;
    }

    case LED_FLASH_CHG_MODE:
    {
        RgbColor c = colourForSOC_LED(soc);
        uint16_t phaseDur = g_chgOnPhase ? CHG_ON_MS : CHG_OFF_MS;
        if (g_chgOnPhase)
            ledSetRGB255(c.r, c.g, c.b);
        else
            ledAllOff();
        if (now - g_chgStampMs >= phaseDur)
        {
            g_chgOnPhase = !g_chgOnPhase;
            g_chgStampMs = now;
        }
        break;
    }
    }
}

#ifdef DUMP_AT_COMMANDS // if enabled it requires the streamDebugger lib
#include <StreamDebugger.h>
StreamDebugger debugger(SerialAT, Serial);
TinyGsm modem(debugger);
#else
TinyGsm modem(SerialAT);
#endif
// It depends on the operator whether to set up an APN. If some operators do not set up an APN,
// they will be rejected when registering for the network. You need to ask the local operator for the specific APN.
// APNs from other operators are welcome to submit PRs for filling.
// #define NETWORK_APN     "CHN-CT"             //CHN-CT: China Telecom
const char *server_url = "https://senditemalert-tg3jk3roea-as.a.run.app";

void postData() 
{
    float lat = gps.location.lat();
    float lng = gps.location.lng();
    float vel = gps.speed.kmph();
    float spd = gps.speed.mps();
    float accuracy = gps.satellites.value();
    String time = "";
    time += String(gps.date.year());
    time += "-";
    if (gps.date.month() < 10) time += "0";
    time += String(gps.date.month());
    time += "-";
    if (gps.date.day() < 10) time += "0";
    time += String(gps.date.day());
    time += "T";
    int sg_hour = gps.time.hour() + 0; // Singapore is UTC +8, change this according to your timezone
    if (sg_hour >= 24) sg_hour -= 24; // wrap around midnight
    if (sg_hour < 10) time += "0";
    time += String(sg_hour);
    // if (gps.time.hour() < 10) time += "0";
    // time += String(gps.time.hour());
    time += ":";
    if (gps.time.minute() < 10) time += "0";
    time += String(gps.time.minute());
    time += ":";
    if (gps.time.second() < 10) time += "0";
    time += String(gps.time.second());
    time += "+08:00"; // add timezone info, change this according to your timezone
    Serial.println("Time: " + time);

    // // Initialize HTTPS
    modem.https_begin();

    // Set GET URT
    if (!modem.https_set_url(server_url))
    {
        Serial.println("Failed to set the URL. Please check the validity of the URL!");
        return;
    }

    // Build the HTTPS POST request header (the below are just some random header examples)
    // modem.https_add_header("Accept-Language", "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6");
    // modem.https_add_header("Accept-Encoding", "gzip, deflate, br");
    modem.https_add_header("Content-Type", "application/json");
    modem.https_add_header("Accept", "application/json");

    // modem.https_set_user_agent("TinyGSM/LilyGo-A76XX");

    // Build the HTTPS POST request body
    // String post_body = "This is post example!";
    //String post_body = String("{\"itemId\":\"0009\",") + "\"location\":{\"lat\":1.35210,\"lng\":103.81980,\"accuracy\":12}," + "\"at\":\"2025-08-09T10:22:00+08:00\"," + "\"severity\":\"warning\"}";
    // String post_body = String("{\"itemId\":\"0001\",") + "\"location\":{\"lat\":" + String(gps.location.lat(), 5) + ",\"lng\":" + String(gps.location.lng(), 5)+ ",\"accuracy\":" + String(gps.satellites.value())+ "}," + "\"at\":\"" + time + "\"," + "\"severity\":\"" + pmaState + "\"" + "}";
    String post_body;
    post_body.reserve(256);  // prevent repeated reallocations
    post_body = "{\"itemId\":\"0001\",";
    post_body += "\"location\":{\"lat\":";
    post_body += String(lat, 5);
    post_body += ",\"lng\":";
    post_body += String(lng, 5);
    post_body += ",\"accuracy\":";
    post_body += String(accuracy);
    post_body += "},\"at\":\"";
    post_body += time;
    post_body += "\",\"severity\":\"";
    post_body += pmaState;
    post_body += "\"}";

    // char post_body[256];
    // snprintf(post_body, sizeof(post_body),
    // "{\"itemId\":\"0001\",\"location\":{\"lat\":%.5f,\"lng\":%.5f,\"accuracy\":%.0f},\"at\":\"%s\",\"severity\":\"%s\"}",
    // lat, lng, accuracy, time.c_str(), pmaState.c_str());


    Serial.println("---- POST body (debug) ----");
    Serial.println(post_body);
    Serial.println("---------------------------");

    // .https_post transmits the HTTPS POST request and returns the HTTP status code (e.g. 200, 400, 500, etc.)
    int httpCode = modem.https_post(post_body);
    if (httpCode < 200 || httpCode >= 300)
    {
        Serial.print("HTTP post failed! status = ");
        Serial.println(httpCode);
        // Optionally print response to see error
        Serial.print("HTTP body (error): ");
        Serial.println(modem.https_body());
        modem.https_end();
        return;
    }

    // Get HTTPS response (response from the server) header information
    String header = modem.https_header();
    Serial.println("_______________________________________________");
    Serial.println("Response Header");
    Serial.println("_______________________________________________");
    Serial.println(header);

    // Get HTTPS response body information
    String body = modem.https_body();
    Serial.println("_______________________________________________");
    Serial.println("Response body : ");
    Serial.println("_______________________________________________");
    Serial.println(body);

    // Disconnect http server
    modem.https_end();

    Serial.println("***********************************************************************************************");
    Serial.println("End of HTTPS POST request and response");
    Serial.println("***********************************************************************************************");

    // SerialGPS.end();//restart gps connection
    // delay(100);
    // SerialGPS.begin(9600, SERIAL_8N1, BOARD_GPS_RX_PIN, BOARD_GPS_TX_PIN);
    //delay(postInterval); // wait 15 seconds
}

float check_angle(float chk_angle)
{
  if (chk_angle > 180)
  {
      chk_angle = chk_angle - 360;
  }
  else if(chk_angle < -180)
  {
      chk_angle = chk_angle + 360;
  }
  return chk_angle;
}

float pitch_threshold_angle = 70;
float roll_threshold_angle = 70;
float threshold_acc = 8;
bool check_fall(float roll, float pitch, float ax, float ay)
{
  if(pitch < -pitch_threshold_angle && ax > threshold_acc)//left fall
  { 
      Serial.println("Left fall");
      return true;
  }else if(pitch > pitch_threshold_angle && ax < -threshold_acc)//right fall
  { 
      Serial.println("Right fall");
      return true;
  }else if(roll < -roll_threshold_angle && ay < -threshold_acc)//forward fall
  { 
      Serial.println("Forward fall");
      return true;
  }else if(roll > roll_threshold_angle && ay > threshold_acc)//backward fall
  { 
      Serial.println("Backward fall");
      return true;
  }
  return false;
}

float pitch_safe_angle = 20;
float roll_safe_angle = 20;
bool check_safe(float roll, float pitch)
{
  if((pitch > -pitch_safe_angle && pitch < pitch_safe_angle) && (roll > -roll_safe_angle && roll < roll_safe_angle))
  {
      Serial.println("PMA returned back to safe position");
      return true;
  }
  return false;
}

void alert() 
{
    Serial.println("Alert sound!");
    int buzz = 0; //counter for buzzer loop
    for (buzz=0; buzz<3; buzz++) 
    {
        digitalWrite(buzzerPin,LOW);
        delay(300);
        digitalWrite(buzzerPin,HIGH);
        delay(50);
    }
    delay(100);
}

static unsigned long lastChars = 0;
static unsigned long lastCheck = 0;
void displayInfo()
{
    if (gps.location.isValid() )
    {
        latitude = gps.location.lat();     //Storing the Lat. and Lon.
        longitude = gps.location.lng();
        bearing = TinyGPSPlus::cardinal(gps.course.value());     // get the direction
        // Serial.print("LATITUDE:  "); Serial.println(latitude, 6);  // float to x decimal places
        // Serial.print("LONGITUDE: "); Serial.println(longitude, 6);
    }
    if (gps.speed.isValid()) 
    {
        velocity = gps.speed.kmph();         //get velocity
        speed_mps = gps.speed.mps();  // kilometers per hour
        // Serial.print("VELOCITY: "); Serial.print(velocity); Serial.println("kmph");
        // Serial.print("SPEED: "); Serial.print(speed_mps); Serial.println("mps");
    }
    if (millis() > printTime + 1000)
    {
        printTime = millis();
        Serial.print("LATITUDE:  "); Serial.println(latitude, 6);  // float to x decimal places
        Serial.print("LONGITUDE: "); Serial.println(longitude, 6);
        //Serial.printf("Sending lat: %.6f, lng: %.6f\n", latitude, longitude);
        //To check if the gps is actually working/updated
        Serial.println(gps.location.isValid() ? "GPS FIXED" : "NO FIX");
        Serial.println(gps.charsProcessed()); // shows how many characters TinyGPS++ has parsed
        Serial.println();
        if (millis() - lastCheck > 5000) 
        {
        lastCheck = millis();
        if (gps.charsProcessed() == lastChars) 
        {
            Serial.println("⚠️ GPS stalled, restarting SerialGPS...");
            SerialGPS.end();
            delay(100);
            //SerialGPS.begin(9600, SERIAL_8N1, BOARD_GPS_RX_PIN, BOARD_GPS_TX_PIN);
            SerialGPS.begin(9600);
        }
        lastChars = gps.charsProcessed();
        }
        // String timeStr;
        // modem.sendAT("+CCLK?");
        // if (modem.waitResponse(1000, "+CCLK:") == 1) {
        // timeStr = modem.stream.readStringUntil('\n');
        // timeStr.trim();
        // Serial.println("Module time: " + timeStr);
        // }
        // SerialAT.println("AT+CTZU?");  // check if automatic time zone update is on
        //SerialAT.println("AT+CTZU=1"); // enable NITZ auto update
    }
}

void gpsTask(void *parameter) 
{
  for (;;) {
    while (SerialGPS.available()) 
    {
      gps.encode(SerialGPS.read());
    //   char c = SerialGPS.read(); // debug to see if the gps is reading any raw nmea sentence, to check if gps is updating
    //   Serial.write(c);
    }
    //Serial.println("gpsTask running..."); //debug to see if the task is running
    vTaskDelay(10 / portTICK_PERIOD_MS); // small delay to yield
  }
}

void topple_detectTask(void* parameter) //rtos
{ 
    for (;;) {
        // We use a non-blocking delay to ensure responsiveness
        mpu.accelUpdate();
        delay(50);
        mpu.gyroUpdate();
        delay(50);

        float ax = mpu.accelX() * g; // convert to m/s^2
        float ay = mpu.accelY() * g;
        float az = mpu.accelZ() * g;
        Accel = sqrt(ax * ax + ay * ay);

        float gx = mpu.gyroX(); // deg/s
        float gy = mpu.gyroY(); //* M_PI/180.0; //to convert to rad/s
        float gz = mpu.gyroZ();
        Gyro = sqrt(gx * gx + gy * gy + gz * gz);
        
        //to replace values in the array
        if (zeroing)
        { 
            totalAccel = totalAccel - readingsAccel[count];
            totalGyro = totalGyro - readingsGyro[count];
            //Serial.print("Total Accel "); Serial.print(totalAccel); Serial.print(" | Total Gyro "); Serial.println(totalGyro);
        }
        readingsAccel[count] = Accel;
        readingsGyro[count] = Gyro;

        //calculating average
        totalAccel = totalAccel + readingsAccel[count];
        totalGyro = totalGyro + readingsGyro[count];
        count++;
        if (!zeroing)
        {
            ind = count;
        }
        averageAccel = totalAccel/ind;
        averageGyro = totalGyro/ind;
        // Serial.print("Average Accel: "); Serial.print(averageAccel);
        // Serial.print(" | Average Gyro: "); Serial.println(averageGyro);

        //to trigger replacing the values
        if (count >= numReadings)
        {
            count = 0;
            zeroing = true;
            //Serial.println("reset");
        }

        //calculate roll and pitch
        float roll = atan( ay/sqrt(ax*ax + az*az) )*1 / (3.142/180);
        float pitch = -atan( ax/sqrt(ay*ay + az*az) )*1 / (3.142/180);
        // Output
        Serial.print("Roll: "); Serial.print(roll);
        Serial.print(" | Pitch: "); Serial.println(pitch);

        // --- Accident Detection Logic ---
        if (millis() - lastUpdateTime > SENSOR_READ_INTERVAL) 
        {

        // Topple/Overturn Detection
        if (check_fall(roll, pitch, ax, ay) && !potentialFall)
        {
        //if (roll > upper_threshold_roll || roll < lower_threshold_roll && !potentialFall){
            potentialFall = true;
            fallTime = millis();
            Serial.println("*************************************************");
            Serial.println("PMA TOPPLED OR OVERTURNED!");
            Serial.println("*************************************************");
            //alert();
            //delay(100); // Pause after alert to avoid spamming
        }

        if (potentialFall && check_safe(roll, pitch))
        { //if the pma has returned into a safe orientation, alarm will stop
            potentialFall = false;
            //Serial.println("False alarm");
        }
        // Check for impact if a fall has been detected after a certain amount of time
        if (millis() - fallTime > stillTime && potentialFall) 
        {
            if (averageAccel > FALL_ACCEL_THRESHOLD && az < 8) 
            { //g-force is x or y direction, indicating the PMA has toppled
                Serial.println("*************************************************");
                Serial.println("PMA TOPPLED, ALERT: PMA FALLEN!!!!! (after a few seconds)");
                Serial.println("*************************************************");
                //alert();
            } 
            else 
            {
                if (check_safe(roll, pitch))
                { //if the pma has returned into a safe orientation, alarm will stop
                    potentialFall = false;
                    //Serial.println("False alarm");
                }
            }
            fallTime = millis();
        }
        lastUpdateTime = millis();
        }
        // --- Print Sensor Values to Serial Monitor ---
        // Serial.print("Accel X: "); Serial.print(ax); Serial.print(" m/s^2, ");
        // Serial.print("Y: "); Serial.print(ay); Serial.print(" m/s^2, ");
        // Serial.print("Z: "); Serial.print(az); Serial.println(" m/s^2 ");
        // Serial.print("Gyro X: "); Serial.print(gx); Serial.print(" deg/s, ");
        // Serial.print("Y: "); Serial.print(gy); Serial.print(" deg/s, ");
        // Serial.print("Z: "); Serial.print(gz); Serial.print(" deg/s ");
        // Serial.print("Roll: "); Serial.print(roll); Serial.print(" deg, ");
        // Serial.print("Pitch: "); Serial.print(pitch); Serial.println(" deg ");
        vTaskDelay(looptime / portTICK_PERIOD_MS); // wait .5 seconds
    }
}

void alertTask(void* parameter) //rtos
{ 
    for (;;) {
        if (potentialFall){
            Serial.println("Alert sound!");
            int buzz = 0; //counter for buzzer loop
            for (buzz=0; buzz<3; buzz++) 
            {
                digitalWrite(buzzerPin,LOW);
                delay(300);
                digitalWrite(buzzerPin,HIGH);
                delay(50);
            }
            //delay(100);
            pmaState = "Toppled";
        }
        else
        {
            pmaState = "Safe";
        }
        vTaskDelay(200 / portTICK_PERIOD_MS); // wait 1 second
    }
}

void setup()
{
    Serial.begin(115200); // Set console baud rate

    Serial.println("Start Sketch");

    SerialAT.begin(115200, SERIAL_8N1, MODEM_RX_PIN, MODEM_TX_PIN);

#ifdef BOARD_POWERON_PIN
    /* Set Power control pin output
     * * @note      Known issues, ESP32 (V1.2) version of T-A7670, T-A7608,
     *            when using battery power supply mode, BOARD_POWERON_PIN (IO12) must be set to high level after esp32 starts, otherwise a reset will occur.
     * */
    pinMode(BOARD_POWERON_PIN, OUTPUT);
    digitalWrite(BOARD_POWERON_PIN, HIGH);
#endif

    // Set modem reset pin ,reset modem
#ifdef MODEM_RESET_PIN
    pinMode(MODEM_RESET_PIN, OUTPUT);
    digitalWrite(MODEM_RESET_PIN, !MODEM_RESET_LEVEL);
    delay(100);
    digitalWrite(MODEM_RESET_PIN, MODEM_RESET_LEVEL);
    delay(2600);
    digitalWrite(MODEM_RESET_PIN, !MODEM_RESET_LEVEL);
#endif

#ifdef MODEM_FLIGHT_PIN
    // If there is an airplane mode control, you need to exit airplane mode
    pinMode(MODEM_FLIGHT_PIN, OUTPUT);
    digitalWrite(MODEM_FLIGHT_PIN, HIGH);
#endif

    // Pull down DTR to ensure the modem is not in sleep state
    pinMode(MODEM_DTR_PIN, OUTPUT);
    digitalWrite(MODEM_DTR_PIN, LOW);

    // Turn on the modem
    pinMode(BOARD_PWRKEY_PIN, OUTPUT);
    digitalWrite(BOARD_PWRKEY_PIN, LOW);
    delay(100);
    digitalWrite(BOARD_PWRKEY_PIN, HIGH);
    delay(100);
    digitalWrite(BOARD_PWRKEY_PIN, LOW);

    // Check if the modem is online
    Serial.println("Start modem...");

    int retry = 0;
    while (!modem.testAT(1000))
    {
        Serial.println(".");
        if (retry++ > 10)
        {
            Serial.println("Powering on and off the modem...");
            digitalWrite(BOARD_PWRKEY_PIN, LOW);
            delay(100);
            digitalWrite(BOARD_PWRKEY_PIN, HIGH);
            delay(1000);
            digitalWrite(BOARD_PWRKEY_PIN, LOW);
            retry = 0;
        }
    }
    Serial.println();

//added
    Serial.println("Battery Box ESP-NOW Initiator + RGB LED Begin");

    ledcSetup(LEDC_CH_R, LEDC_FREQ_HZ, LEDC_RES_BITS);
    ledcSetup(LEDC_CH_G, LEDC_FREQ_HZ, LEDC_RES_BITS);
    ledcSetup(LEDC_CH_B, LEDC_FREQ_HZ, LEDC_RES_BITS);
    ledcAttachPin(LED_R_PIN, LEDC_CH_R);
    ledcAttachPin(LED_G_PIN, LEDC_CH_G);
    ledcAttachPin(LED_B_PIN, LEDC_CH_B);
    ledAllOff();

//     // Set ESP32 as a Wi-Fi Station
//     WiFi.mode(WIFI_STA);

//     // Print MAC addresses
//     Serial.print("My MAC Address: ");
//     Serial.println(WiFi.macAddress());
//     Serial.print("Responder MAC Address: ");
//     char macStr[18];
//     formatMacAddress(responderAddress, macStr, 18);
//     Serial.println(macStr);

//     // Disconnect from WiFi
//     WiFi.disconnect();

//     // Initialize ESP-NOW
//     if (esp_now_init() == ESP_OK)
//     {
//         Serial.println("ESP-NOW Init Success");
//         // Bind the send callback
//         esp_now_register_send_cb(sendingCallback);
//     }
//     else
//     {
//         Serial.println("ESP-NOW Init Failed");
//         delay(3000);
//         ESP.restart();
//     }

//     // Register peer
//     memcpy(peerInfo.peer_addr, responderAddress, 6);
//     peerInfo.channel = 0;
//     peerInfo.encrypt = false;

//     // Add peer
//     if (esp_now_add_peer(&peerInfo) != ESP_OK)
//     {
//         Serial.println("Failed to add peer");
//         return;
//     }

    bms.Init();
    BMS_SERIAL.begin(9600, SERIAL_8N1, BMS_TX, BMS_RX); // Map UART1's RX to GPIO21 and the TX to GPIO22

// #if TEST_MODE == 2 // AUTO
//     bms_ok = true; // we’ll generate fake data
//     input_soc = 101;
//     test_case = 1;
// #endif

//added
    //SerialGPS.begin(9600, SERIAL_8N1, BOARD_GPS_RX_PIN, BOARD_GPS_TX_PIN);
    SerialGPS.begin(9600);
    delay(2000);
    while (!Serial) {
      delay(10); // Wait for serial port to connect.
    }

    Serial.println("PMA Accident Detection System Initializing...");
    //Wire.begin();
    Wire.begin(SDA_PIN, SCL_PIN, 100000);
    delay(1000); // Stabilization delay for GY-91

    pinMode(buzzerPin,OUTPUT);
    digitalWrite(buzzerPin,HIGH);
    delay(50);

    // Initialize MPU9250
    mpu.setWire(&Wire);
    mpu.beginAccel();
    mpu.beginGyro();
    delay(1000);

    // Diagnostic check
    Wire.beginTransmission(0x68); // MPU9250 default address
    Wire.write(0x75); // WHO_AM_I register
    Wire.endTransmission(false);
    Wire.requestFrom(0x68, 1);
    if (Wire.available()) {
    byte whoami = Wire.read();
    Serial.print("WHO_AM_I: 0x");
    Serial.println(whoami, HEX);
    }
    
    Serial.println("Initialization Complete. Monitoring for accidents...");
    Serial.println("----------------------------------------------------");

    Serial.println("Testing TinyGSM modem...");
    if (modem.testAT()) {
    Serial.println("✅ Modem responded OK!");
    } else {
    Serial.println("❌ No response from modem.");
    }

    Serial.println("Sending AT...");
    SerialAT.println("AT");   // directly send to the modem
    SerialAT.flush();
    unsigned long start = millis();

    while (millis() - start < 2000) {  // wait up to 2s for a reply
        while (SerialAT.available()) {
            char c = SerialAT.read();
            Serial.write(c);  // echo modem's raw reply
        }
    }
    Serial.println("Done checking AT.");

    modem.sendAT("");
    delay(200);
    while (modem.stream.available()) Serial.write(modem.stream.read());
    // Check if SIM card is online
    SimStatus sim = SIM_ERROR;
    while (sim != SIM_READY)
    {
        sim = modem.getSimStatus();
        Serial.println("Checking SIM card status...");
        Serial.printf("SIM status: %d\n", sim);
        switch (sim)
        {
        case SIM_READY:
            Serial.println("SIM card online");
            break;
        case SIM_LOCKED:
            Serial.println("The SIM card is locked. Please unlock the SIM card first.");
            // const char *SIMCARD_PIN_CODE = "123456";
            // modem.simUnlock(SIMCARD_PIN_CODE);
            break;
        default:
            Serial.println("❌ SIM not detected or communication error.");
            SerialAT.println("AT+CPIN?");
            modem.sendAT("+CPIN?");
            delay(500);
            //modem.waitResponse(1000, "OK");
            unsigned long start = millis();
            while (millis() - start < 3000) {
            while (modem.stream.available()) 
            {
                String line = modem.stream.readStringUntil('\n');
                line.trim();
                if (line.length()) 
                {
                    Serial.println(">> " + line);
                }
            }
            }
            break;
        }
        delay(1000);
    }

    // SIM7672G Can't set network mode
// #ifndef TINY_GSM_MODEM_SIM7672
//     if (!modem.setNetworkMode(MODEM_NETWORK_AUTO))
//     {
//         Serial.println("Set network mode failed!");
//     }
//     String mode = modem.getNetworkModes();
//     Serial.print("Current network mode : ");
//     Serial.println(mode);
// #endif

#ifdef NETWORK_APN
    Serial.printf("Set network apn : %s\n", NETWORK_APN);
    modem.sendAT(GF("+CGDCONT=1,\"IP\",\""), NETWORK_APN, "\"");
    if (modem.waitResponse() != 1)
    {
        Serial.println("Set network apn error !");
    }
#endif

    // Check network registration status and network signal status
    int16_t sq;
    Serial.print("Wait for the modem to register with the network.");
    RegStatus status = REG_NO_RESULT;
    while (status == REG_NO_RESULT || status == REG_SEARCHING || status == REG_UNREGISTERED)
    {
        status = modem.getRegistrationStatus();
        switch (status)
        {
        case REG_UNREGISTERED:
        case REG_SEARCHING:
            sq = modem.getSignalQuality();
            Serial.printf("[%lu] Signal Quality:%d\n", millis() / 1000, sq);
            delay(1000);
            break;
        case REG_DENIED:
            Serial.println("Network registration was rejected, please check if the APN is correct");
            return;
        case REG_OK_HOME:
            Serial.println("Online registration successful");
            break;
        case REG_OK_ROAMING:
            Serial.println("Network registration successful, currently in roaming mode");
            break;
        default:
            Serial.printf("Registration Status:%d\n", status);
            delay(1000);
            break;
        }
    }
    Serial.println();

#ifdef MODEM_REG_SMS_ONLY
    while (status == REG_SMS_ONLY)
    {
        Serial.println("Registered for \"SMS only\", home network (applicable only when E-UTRAN), this type of registration cannot access the network. Please check the APN settings and ask the operator for the correct APN information and the balance and package of the SIM card. If you still cannot connect, please replace the SIM card and test again. Related ISSUE: https://github.com/Xinyuan-LilyGO/LilyGO-T-A76XX/issues/307#issuecomment-3034800353");
        delay(5000);
    }
#endif

    Serial.printf("Registration Status:%d\n", status);
    delay(1000);

    String ueInfo;
    if (modem.getSystemInformation(ueInfo))
    {
        Serial.print("Inquiring UE system information:");
        Serial.println(ueInfo);
    }

    if (!modem.setNetworkActive())
    {
        Serial.println("Enable network failed!");
    }

    delay(5000);

    String ipAddress = modem.getLocalIP();
    Serial.print("Network IP:");
    Serial.println(ipAddress);

    // Note - The above is similar to that in Network.ino

    // // Initialize HTTPS
    // modem.https_begin();

    // // Set GET URT
    // if (!modem.https_set_url(server_url))
    // {
    //     Serial.println("Failed to set the URL. Please check the validity of the URL!");
    //     return;
    // }

    // // Build the HTTPS POST request header (the below are just some random header examples)
    // // modem.https_add_header("Accept-Language", "zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6");
    // // modem.https_add_header("Accept-Encoding", "gzip, deflate, br");

    // modem.https_add_header("Content-Type", "application/json");
    // modem.https_add_header("Accept", "application/json");

    // // modem.https_set_user_agent("TinyGSM/LilyGo-A76XX");

    // // Build the HTTPS POST request body
    // String post_body = "This is post example!";
    // String post_body = String("{\"itemId\":\"0009\",") + "\"location\":{\"lat\":1.35210,\"lng\":103.81980,\"accuracy\":12}," + "\"at\":\"2025-08-09T10:22:00+08:00\"," + "\"severity\":\"warning\"}";
    // String post_body = String("{\"itemId\":\"0009\",") + "\"location\":{\"lat\":" + String(gps.location.lat(), 6) + ",\"lng\":" + String(gps.location.lng(), 6)+ ",\"accuracy\":" + String(gps.satellites.value())+ "}," + "\"at\":\"2025-08-09T10:22:00+08:00\"," + "\"severity\":" + pmaState + "}";

    // Serial.println("---- POST body (debug) ----");
    // Serial.println(post_body);
    // Serial.println("---------------------------");

    // // // .https_post transmits the HTTPS POST request and returns the HTTP status code (e.g. 200, 400, 500, etc.)
    // int httpCode = modem.https_post(post_body);
    // if (httpCode < 200 || httpCode >= 300)
    // {
    //     Serial.print("HTTP post failed! status = ");
    //     Serial.println(httpCode);
    //     // Optionally print response to see error
    //     Serial.print("HTTP body (error): ");
    //     Serial.println(modem.https_body());
    //     modem.https_end();
    //     return;
    // }

    // Serial.println("***********************************************************************************************");
    // Serial.println("Response to the HTTPS POST request");
    // Serial.println("***********************************************************************************************");

    // // // Get HTTPS response (response from the server) header information
    // String header = modem.https_header();
    // Serial.println("_______________________________________________");
    // Serial.println("Response Header");
    // Serial.println("_______________________________________________");
    // Serial.println(header);

    // // // Get HTTPS response body information
    // String body = modem.https_body();
    // Serial.println("_______________________________________________");
    // Serial.println("Response body : ");
    // Serial.println("_______________________________________________");
    // Serial.println(body);

    // // // Disconnect http server
    // modem.https_end();

    // Serial.println("***********************************************************************************************");
    // Serial.println("End of HTTPS POST request and response");
    // Serial.println("***********************************************************************************************");

//added
    lastUpdateTime = millis();
    // xTaskCreate(
    // relayTask,       // Task function
    // "RelayTask",     // Name
    // 8192,           // Stack size
    // NULL,           // Parameters
    // 1,              // Priority
    // NULL            // Task handle
    // );

    xTaskCreate(
    gpsTask,
    "GPSTask",
    4096,
    NULL,
    3,     // Highest priority
    NULL
    );

    xTaskCreate(
    topple_detectTask,
    "Topple_DetectTask",
    4096,
    NULL,
    2,     // Lower priority than GPSTask
    NULL
    );
    delay(10000); // Wait for tasks to initialize

    xTaskCreate(
    alertTask,
    "AlertTask",
    4096,
    NULL,
    1,     // Lower priority than Topple_DetectTask
    NULL
    );
    delay(10000); // Wait for tasks to initialize
}

void loop()
{
//     #if TEST_MODE == 0 // ACTUAL
//     // NOTE - Actual raw readings from BMS
    // bms_ok = bms.update();
    // input_soc = bms.get.packSOC;   //! ceiling to nearest upper int do at responder side
    // input_I = bms.get.packCurrent; // +A charge, -A discharge //! condition for input_chg do at responder side
    // input_resmAh = bms.get.resCapacitymAh;

// #elif TEST_MODE == 1 // MANUAL
//     // NOTE - Manual Test
//     bms_ok = true;
//     input_soc = 20;
//     input_I = 0.55;
//     input_resmAh = 11000;

// #elif TEST_MODE == 2 // AUTO
//     // NOTE - Auto Test
//     if (millis() - lastAutoTestms >= AUTO_TEST_MS)
//     {
//         if ((input_soc <= 21 && test_case == 1) || (input_soc >= 94 && test_case == 2))
//         {
//             AUTO_TEST_MS = 3000;
//         }
//         else
//         {
//             AUTO_TEST_MS = 500;
//         }
//         if (input_soc == 0)
//         {
//             test_case = 2; // Charge test
//         }
//         if (input_soc == 100)
//         {
//             test_case = 1; // Discharge test
//         }

//         if (test_case == 1) // Discharge test
//         {
//             input_soc--;
//             input_I = -10; // -10A discharge
//             input_resmAh = 11000 * input_soc / 100;
//         }
//         else if (test_case == 2) // Charge test
//         {
//             input_soc++;
//             input_I = 10; // +10A charge
//             input_resmAh = 11000 * input_soc / 100;
//         }
//         lastAutoTestms = millis();
//     }
// #endif

//     uint32_t now = millis();

//     if (now - lastSendMs >= SEND_PERIOD_MS)
//     {
//         Serial.println("----------------------------------------------------");
//         Serial.print("BMS Status: ");
//         Serial.println(bms_ok);
//         Serial.print("BMS SoC: ");
//         Serial.println(input_soc);
//         Serial.print("BMS Current: ");
//         Serial.println(input_I);
//         Serial.print("BMS Remaining Capacity (mAh): ");
//         Serial.println(input_resmAh);
//         Serial.println();

//         // Input the test data into the struct
//         BMSData.bms_status = bms_ok;
//         BMSData.soc = input_soc;
//         BMSData.I = input_I;
//         BMSData.resmAh = input_resmAh;

//         // Send message via ESP-NOW
//         esp_err_t result = esp_now_send(responderAddress, (uint8_t *)&BMSData, sizeof(BMSData));

//         // Print results to serial monitor
//         if (result == ESP_OK)
//         {
//             Serial.println("Sending confirmed");
//             Serial.println("Sent data: ");
//             Serial.print("BMS Status: ");
//             Serial.println(BMSData.bms_status);
//             Serial.print("BMS SoC: ");
//             Serial.println(BMSData.soc);
//             Serial.print("BMS Current: ");
//             Serial.println(BMSData.I);
//             Serial.print("BMS Remaining Capacity (mAh): ");
//             Serial.println(BMSData.resmAh);
//         }
//         else if (result == ESP_ERR_ESPNOW_NOT_INIT)
//         {
//             Serial.println("ESP-NOW not Init.");
//         }
//         else if (result == ESP_ERR_ESPNOW_ARG)
//         {
//             Serial.println("Invalid Argument");
//         }
//         else if (result == ESP_ERR_ESPNOW_INTERNAL)
//         {
//             Serial.println("Internal Error");
//         }
//         else if (result == ESP_ERR_ESPNOW_NO_MEM)
//         {
//             Serial.println("ESP_ERR_ESPNOW_NO_MEM");
//         }
//         else if (result == ESP_ERR_ESPNOW_NOT_FOUND)
//         {
//             Serial.println("Peer not found.");
//         }
//         else
//         {
//             Serial.println("Unknown error");
//         }

//         lastSendMs = now;
//     }

//     int soc_i = clampi((int)ceilf(input_soc), 0, 100);
//     int chg = (input_I > 0.5f) ? 1 : 0; // >+0.5A = charging
//     statusMessage(soc_i, chg);          // sets g_status
//     updateLED(soc_i, chg);              // non-blocking LED state machine

//     delay(1);

    //BMS Debugger
    // Serial.println("----------------------------------------------------");
    // Serial.print("BMS Status: ");
    // Serial.println(bms.update());
    // Serial.print("BMS SoC: ");
    // Serial.println(bms.get.packSOC);
    // Serial.print("BMS Current: ");
    // Serial.println(bms.get.packCurrent);
    // Serial.print("BMS Remaining Capacity (mAh): ");
    // Serial.println(bms.get.resCapacitymAh);
    // Serial.println();  

    //added
    displayInfo();  
    // if (potentialFall){
    //     alert();
    //     pmaState = "Toppled";
    // }else{
    //     pmaState = "Safe";
    // }
    if (millis() - postTime > postInterval)//call it once every interval
    { 
        Serial.println("Posting data...");
        postData(); //commented out to use rtos task instead
        postTime = millis();
        Serial.println("Post data done.");
    }

    // Debug AT
    if (SerialAT.available())
    {
        Serial.write(SerialAT.read());
    }
    if (Serial.available())
    {
        SerialAT.write(Serial.read());
    }
    delay(1);
}


#ifndef TINY_GSM_FORK_LIBRARY
#error "No correct definition detected, Please copy all the [lib directories](https://github.com/Xinyuan-LilyGO/LilyGO-T-A76XX/tree/main/lib) to the arduino libraries directory , See README"
#endif
/*
SIM7600 Version OK 20250709
AT+SIMCOMATI
Manufacturer: SIMCOM INCORPORATED
Model: SIMCOM_SIM7600G-H
Revision: LE20B04SIM7600G22
QCN:
IMEI: xxxxxxxxxxxx
MEID:
+GCAP: +CGSM
DeviceInfo: 173,170

SIM7000G    # 2025/07/10:OK!
Revision:1529B11SIM7000G
CSUB:V01
APRev:1529B11SIM7000,V01
QCN:MDM9206_TX3.0.SIM7000G_P1.03C_20240911

Revision:1529B11SIM7000G
CSUB:V01
APRev:1529B11SIM7000,V01
QCN:MDM9206_TX3.0.SIM7000G_P1.02_20180726
*/
